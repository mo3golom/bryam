# Project Agents.md Guide for AI agentic developer

This Agents.md file provides comprehensive guidance for AI agentic developers working with this codebase.

## Coding Conventions for AI agentic developer

### General Conventions
- AGENT SHOULD use the latest version of any package. Before add any dependency check the version using Context7
- AGENT HAVE TO add any dependency using "npm install ..." command
- AGENT HAVE TO use DOMAIN DRIVEN DESIGN and TEST DRIVEN DEVELOPMENT approaches when implement new features
- Define bounded contexts to separate different parts of the domain with clear boundaries
- Implement ubiquitous language within each context to align code with business terminology
- Agents.md requires meaningful variable and function names in AI agentic developer output
- AGENT SHOULD add comments ONLY for complex logic as guided by Agents.md
- AGENT SHOULD favor elegant, maintainable solutions over verbose code. Assume understanding of language idioms and design patterns.

### GIT
- AGENT HAVE TO commit all changes after implement the task using "git add ." and "git commit -m" commands. 
- AGENT SHOULD write meaningful commit messages that describe the changes made in the commit.

#### DOC_UPDATES
- Update relevant documentation in /docs when modifying features
- Keep README.md in sync with new capabilities

### Svelte and SvelteKit
- AGENT HAVE TO run "npm run check" when finished implement any task for checking and fixing errors
- AGGENT HAVE TO use "$env/dynamic/private" import for env variables.
Example:
```js
import { env } from '$env/dynamic/private';

export const supabase = createClient(env.SUPABASE_URL, env.SUPABASE_ANON_KEY)
```
- Use server-side load functions to fetch data before rendering pages
- Leverage SvelteKit's server-only modules for sensitive operations
- Implement route groups (folders with parentheses) for logical organization without URL impact
- Use the new Embedded SvelteKit plugin system

### Tailwindcss
- AGENT SHOULD follow the Tailwind zero-confg approach when implement new features

### Migrations
- Write all new migrations in the `migrations` directory.
- Use the naming convention `NNN-description.sql` for migration files, where `NNN` is a three-digit number (e.g., `001`, `002`, etc.) and `description` is a short, descriptive name of the migration (e.g., `create-license-table`).
- Use PostgreSQL syntax in all new migrations generated by AI agentic developer.
- Each migration should have only an `up` direction. Do not include a `down` direction. Avoid adding `UP` and `DOWN` tags in the migration file.
- All SQL queries should be written in lowercase.
- Always ensure that the migration file is idempotent and can be safely applied multiple times without causing errors.
- Include comments in the migration file to explain the purpose of the migration and any complex logic.
- Avoid using DDL statements that are not supported by the target PostgreSQL version.
- Keep migration files focused on a single task or change to maintain clarity and simplicity.
- Example migration file:
  ```sql
  -- 011-create-license-table.sql

  create table license (
      id uuid primary key,
      name text not null,
      created_at timestamp with time zone not null default now()
  );
  ```

## Unit tests

- If the task EXPLICITLY DOES NOT SPECIFY creating tests, then tests DO NOT need to be created.
- AGENT HAVE TO run "npm run test:run" when finished implement any task any ONLY when "npm run check" was successful.

### VITEST
- Leverage the `vi` object for test doubles - Use `vi.fn()` for function mocks, `vi.spyOn()` to monitor existing functions, and `vi.stubGlobal()` for global mocks. Prefer spies over mocks when you only need to verify interactions without changing behavior.
- Master `vi.mock()` factory patterns - Place mock factory functions at the top level of your test file, return typed mock implementations, and use `mockImplementation()` or `mockReturnValue()` for dynamic control during tests. Remember the factory runs before imports are processed.
- Create setup files for reusable configuration - Define global mocks, custom matchers, and environment setup in dedicated files referenced in your `vitest.config.ts`. This keeps your test files clean while ensuring consistent test environments.
- Handle optional dependencies with smart mocking - Use conditional mocking to test code with optional dependencies by implementing `vi.mock()` with the factory pattern for modules that might not be available in all environments.
- Configure jsdom for DOM testing - Set `environment: 'jsdom'` in your configuration for frontend component tests and combine with testing-library utilities for realistic user interaction simulation.
- Structure tests for maintainability - Group related tests with descriptive `describe` blocks, use explicit assertion messages, and follow the Arrange-Act-Assert pattern to make tests self-documenting.
- Leverage TypeScript type checking in tests - Enable strict typing in your tests to catch type errors early, use `expectTypeOf()` for type-level assertions, and ensure mocks preserve the original type signatures.
- Use inline snapshots for readable assertions - Replace complex equality checks with `expect(value).toMatchInlineSnapshot()` to capture expected output directly in your test file, making changes more visible in code reviews.